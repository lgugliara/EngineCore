using UnityEngine;
using ZoloSim.EngineCore.Enums;

// ZoloSim Engine Core - © 2025 Lorenzo Gugliara
// Author: Lorenzo Gugliara | https://github.com/lgugliara
// License: MIT

namespace ZoloSim.EngineCore
{
    [RequireComponent(typeof(Ignition))]
    [RequireComponent(typeof(Clutch))]
    public class Engine : Part
    {
        #region Components

        // Ignition system (handles engine start/stop)
        public Ignition ignition => GetComponent<Ignition>();

        // Clutch system (handles engine-to-transmission connection)
        public Clutch clutch => GetComponent<Clutch>();

        #endregion

        [Tooltip("Interpolation factor for torque calculation between frames. 0 = no interpolation, 1 = full interpolation. For more accurate simulation, use 0 and set Time > fixedDeltaTime to 0.005f or lower in Unity settings.")]
        [Range(0f, 1f)]
        public float interpolationDamping = 0f;                                                             // Interpolation factor for torque calculation between frames
        
        public float torque { get; set; }                                                                   // Current torque applied [Nm]
        public float angularMomentum { get; set; }                                                          // Current angular momentum [kg·m²/s]
        public float frequency => angularMomentum == 0f ? 0f : data.engine.inertia / angularMomentum;       // Cycle frequency (time per engine cycle) [s⁻¹]
        public float angularVelocity => angularMomentum / data.engine.inertia;                              // Current angular velocity [rad/s]
        public float rpm => angularVelocity * 30f / Mathf.PI;                                               // Revolutions per minute [RPM]
        public float horsePower => angularMomentum * rpm / 745.7f;                                          // Estimated horsepower [hp]

        void FixedUpdate()
        {
            float torqueVel = 0f;

            torque = Mathf.SmoothDamp(torque, availableTorque, ref torqueVel, interpolationDamping, Mathf.Infinity, Time.fixedDeltaTime);
            
            angularMomentum += torque * Time.fixedDeltaTime;
            angularMomentum -= data.engine.internalFriction * angularMomentum * Time.fixedDeltaTime;
        }

        // Reset the engine state (used when restarting the sim)
        public override void Reset()
        {
            torque = 0f;
            angularMomentum = 0f;
        }

        #region Internal Torque Calculation

        // Torque generated by combustion process [Nm]
        private float erogatedTorque
        {
            get
            {
                // If the engine isn't ignited, check if it's trying to ignite
                if (!ignition.IsIgnited)
                    return ignition.IsIgniting ? 25f : 0f;

                // Combustion effectiveness depends on time available per cycle
                float cycleTime = frequency;
                float combustionTime = data.engine.injection.combustionTime * (1f + Random.Range(-0.01f, 0.01f));

                float combustionEfficiency = cycleTime > combustionTime
                    ? 1f
                    : 1f - (combustionTime / cycleTime);

                return data.engine.maxTorqueMetric * combustionEfficiency * ignition.IgnitionLevel;
            }
        }

        // Final torque delivered after ignition logic and modifiers
        private float availableTorque =>
            !ignition.IsIgnited
                ? (ignition.IsIgniting ? 100f : 0f)
                : ignition.IgnitionLevel * erogatedTorque;

        #endregion
    }
}
